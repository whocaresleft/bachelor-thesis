% !TEX root = ../Thesis.tex

\chapter{Conclusione}\label{cap:06}
Il Capitolo~\ref{cap:02}, ha ripercorso le origini del linguaggio e le motivazioni alla base del suo sviluppo, 
evidenziando come si sia evoluto in breve tempo, da progetto personale e sperimentale, in uno strumento adottato da un ampio numero di sviluppatori e aziende. \hfill
\vspace{10pt}\\
\noindent Nel Capitolo~\ref{cap:03}, sono stati analizzati a fondo i meccanismi di \textit{ownership}, \textit{borrowing} e \textit{lifetime}, che costituiscono 
il fulcro del modello di gestione della memoria del linguaggio. 
Questi strumenti hanno mostrato come Rust riesce a garantire simultaneamente sicurezza e controllo, aspetti
fondamentali per lo sviluppo di basso livello. \hfill
\vspace{10pt}\\
\noindent Il Capitolo~\ref{cap:04}, ha preso in analisi il linguaggio C come riferimento
storico e pratico, ricostruendo le caratteristiche che lo hanno reso centrale nella programmazione di sistema: 
\textit{compilazione}, \textit{assenza di runtime}, \textit{manipolazione della memoria} e dei \textit{bit}.
Rust è stato successivamente confrontato con C sia negli aspetti precedentemente elencati, sia in 
aspetti trasversali, quali \textit{gestione delle risorse}, \textit{sicurezza della memoria}, \textit{complessità della sintassi} e \textit{prestazioni}.

Ne è emerso un quadro in cui Rust rappresenta una valida alternativa, nella teoria, a C, 
a costo di una curva di apprendimento più ripida rispetto a quest'ultimo. \hfill
\vspace{10pt}\\
\noindent Infine, il Capitolo~\ref{cap:05}, ha illustrato progetti
concreti già in corso che sperimentano l'uso del linguaggio nello sviluppo di sistemi operativi e 
componenti critici. Queste iniziative mostrano come il linguaggio non sia più una 
premessa puramente teorica, ma uno strumento concreto già in grado di produrre risultati significativi. \hfill
\vspace{10pt}\\
\noindent Nel complesso, l'analisi ha messo in luce le potenzialità e i limiti di Rust nello sviluppo di 
basso livello.
Rust appare in grado di portare benefici significativi nello sviluppo di applicazioni di basso livello e, in particolare, di sistemi operativi.
Grazie al \textit{modello di ownership}, gli errori di gestione della memoria dinamica vengono di fatto eliminati a tempo di compilazione; inoltre 
le astrazioni \textit{zero-cost} e l'impiego di \textit{smart pointer} consentono una gestione sicura della concorrenza, prevenendo interamente le \textit{data race}.

Tuttavia, Rust non rappresenta una soluzione magica né priva di limitazioni. La sintassi e il \textit{Borrow Checker} richiedono tempo e dedizione per essere
padroneggiati, definendo una curva di apprendimento molto più ripida rispetto a linguaggi più permissivi come Python o anche C. A questo va aggiunto il fatto 
che Rust si limita a prevenire gli errori di gestione della memoria, ma non quelli logici: la correttezza di un algoritmo o di un'implementazione 
rimane ancora pienamente responsabilità del programmatore. \hfill 
\vspace{10pt}\\
\noindent È quindi opportuno, o comunque consigliato, evitare un impiego indiscriminato del linguaggio. Da un lato, utilizzare Rust in contesti 
dove i suoi vantaggi non si traducono in benefici concreti 
(ad esempio, \  un'applicazione che non lavora con una quantità significativa di memoria dinamica)
rischia di introdurre soltanto complessità;
dall'altro, utilizzare Rust come se fosse un'altro linguaggio, aggirando o utilizzando in maniera scorretta i costrutti 
disponibili (per esempio scrivendo ampie porzioni di codice \textit{unsafe}) vanifica gran parte dei 
principi alla base del linguaggio stesso. \hfill 
\vspace{10pt}\\
\noindent La prospettiva più equilibrata è dunque quella di impiegare Rust nei contesti critici, in cui sia le prestazioni che la sicurezza della memoria sono 
fondamentali e in cui i vantaggi offerti si traducono in maniera concreta, evitando un uso eccessivo o improprio che ne comprometterebbe i punti di forza.