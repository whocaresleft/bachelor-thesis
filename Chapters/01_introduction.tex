% !TEX root = ../Thesis.tex

\chapter{Introduzione}\label{cap:01}
Negli ultimi anni il linguaggio di programmazione \textit{Rust} ha suscitato 
un crescente interesse, attirando l'attenzione di sviluppatori e aziende.
Una delle motivazioni principali risiede nel suo approccio alla 
gestione della memoria dinamica, da sempre un tema cruciale nello sviluppo di sistemi di basso livello.

Storicamente, si sono affermati due approcci alla gestione della memoria dinamica: 
quello \textit{manuale}, adottato dai primi linguaggi di programmazione come 
l'assembly e, successivamente, dal C
e quello \textit{automatico}, basato su \textit{Garbage Collection} (\textit{GC}), introdotto nel 1959 
da Lisp e oggigiorno impiegato da Java, Python, C\# o anche GO, insieme a tanti altri linguaggi considerati di alto livello. 

L'approccio manuale rende il programmatore interamente responsabile 
della gestione della memoria, introducendo potenzialmente una vasta gamma di errori dovuti al 
fattore umano; la \textit{GC}, invece, solleva il programmatore 
da tale incarico, ma introduce un overhead non trascurabile e riduce 
la trasparenza e il controllo sulla memoria.

Nel contesto delle applicazioni di basso livello, soprattutto dei sistemi 
operativi, controllo diretto e prestazioni sono requisiti fondamentali; 
per questo, l'approccio manuale rappresenta nella pratica l'unica soluzione percorribile.
È in questo contesto che si inserisce Rust, un linguaggio sviluppato per 
garantire una gestione sicura della memoria dinamica, senza impiegare \textit{GC}, e, 
quindi, senza compromettere le prestazioni. \hfill 
\vspace{8pt}\\
\noindent In questa tesi verrà analizzato Rust, con l'obiettivo di comprendere le 
motivazioni alla base della sua crescente diffusione e di valutare gli 
strumenti effettivamente offerti.

\section{Argomento}
La presente ricerca prende in esame la crescente popolarità di Rust nell'ambito
 della programmazione di basso livello, in particolare nello sviluppo di sistemi operativi.

 Nel corso della trattazione verranno richiamati concetti tipici della programmazione di sistema, principalmente
in ambiente Unix, come l'uso dei puntatori, le librerie \texttt{POSIX} e, in generale, elementi del linguaggio C, accompagnati da listati di codice.
Per chiarire alcuni degli aspetti peculiari di Rust, specialmente quelli di alto livello o con un livello di astrazione maggiore, saranno
 proposte anche delle analogie con il linguaggio Java.

Nonostante una conoscenza di base sia di C che di Java possa agevolare la comprensione dei contenuti, non è strettamente necessaria:
i concetti più tecnici saranno accompagnati da spiegazioni accessibili, ove possibile\footnote{Rust offre diversi meccanismi riconducibili alla 
programmazione orientata agli oggetti (\textit{Object-Oriented Programming}, \textit{OOP}). Ho scelto di utilizzare delle analogie in Java per spiegare
questi strumenti in quanto Java è un linguaggio frequentemente utilizzato per introdurre la \textit{OOP} nei corsi universitari. 
Anche se non è indispensabile, ritengo che una familiarità, anche di base, con Java, può risultare utile: alcuni elementi caratteristici della \textit{OOP} risultano difficili 
da spiegare, nella loro interezza, senza le basi del paradigma.}.\\


\noindent Rust ha una premessa chiara: prevenire interi classi di problemi legati
 alla gestione della memoria a livello di compilazione, 
fornendo allo stesso tempo prestazioni, in termini di velocità d'esecuzione, 
paragonabili a C e C++. 

Vi sono, per tale motivo, varie iniziative che mirano a inserire il linguaggio
 come valida opzione nello sviluppo di sistemi operativi,
ma la sua integrazione solleva questioni fondamentali, sia da un punto di vista
 di tradizione (in quanto storicamente C è un pilastro nello sviluppo di sistemi
  operativi), che di spesa, in termini di tempo, 
 per imparare un nuovo linguaggio e per mantenere
  contemporaneamente due flussi di sviluppo paralleli (C e Rust).

\section{Motivazioni}
Ho scelto di approfondire il linguaggio Rust per un interesse personale nelle tematiche della 
programmazione di basso livello, specialmente in C, e della \textit{Cybersecurity}.

Durante il mio percorso di studi, ho avuto modo di confrontarmi più volte con il linguaggio C, sviluppando 
un certo interesse sia verso il linguaggio che verso le sue comuni applicazioni, come \textit{sistemi embedded} e, in generale, software che 
interagisce con il sistema operativo. 

Questo mi ha portato, più volte, a incorrere in comuni errori di memoria (principalmente \textit{Segmentation Fault} e \textit{Buffer Overflow});
inoltre, sempre durante il percorso di studi, ho avuto modo di acquisire conoscenze, sia teoriche che pratiche, di Cybersecurity (da un punto di vista offensivo, ovvero da \textit{Penetration tester} o \textit{White Hacker})
e ho avuto modo di osservare come la maggior parte degli errori o delle falle nelle applicazioni possano essere sfruttati per diversi scopi, anche malevoli (per eseguire \textit{login bypass} o per accedere ad aree di memoria contenenti dati sensibili).

Questo mi ha portato a riflettere su come fosse possibile rendere codice scritto in C sicuro, con lo scopo di prevenire 
errori che potessero essere sfruttati. Tuttavia, proprio in questo contesto, sono arrivato a 
conoscenza di Rust, il quale ha attirato la mia attenzione, sia per la sua premessa del tutto innovativa, che per la sua crescente adozione, specialmente nella 
programmazione di basso livello.



\section{Obiettivi} 
L'obiettivo principale di questa tesi è offrire una panoramica sul linguaggio 
di programmazione Rust, esponendo quelle che sono le motivazioni 
dietro il suo sviluppo e la sua popolarità; successivamente, verrà analizzato 
l'approccio alternativo di gestione della memoria implementato dal linguaggio.

Un altro obiettivo è quello di stabilire se, nella teoria, Rust rappresenti una valida 
opzione per la programmazione di basso livello. Verranno innanzitutto stabiliti i requisiti 
fondamentali di un linguaggio per lo sviluppo di sistemi operativi; successivamente Rust verrà 
confrontato con C, standard \textit{de facto} per la programmazione di basso 
livello, sulla base di gestione delle risorse, della memoria e degli errori, complessità della sintassi e 
prestazioni, fornendo a tale scopo anche esempi di codice.

Come aspetto finale, verranno proposti progetti 
concreti che mostrano come la popolarità del linguaggio non sia solo 
teorica, ma rappresenti uno strumento pratico e in grado di portare risultati concreti.

L'analisi combina aspetti teorici (descrizione dei meccanismi ed esempi di codice)
 con lo studio di casi concreti, per evidenziare sia i principi 
alla base del linguaggio sia le sue applicazioni pratiche. 

\section{Struttura} 
Questa tesi è strutturata in due parti principali, la prima adotterà un approccio di analisi teorica, mentre 
la seconda presenterà esempi concreti di applicazioni reali.
La prima parte è suddivisa in tre capitoli: Capitolo~\ref{cap:02}, Capitolo~\ref{cap:03} e Capitolo~\ref{cap:04}; mentre la seconda parte è composta interamente dal Capitolo~\ref{cap:05}. \hfill
\vspace{7pt}\\
\noindent Nel Capitolo~\ref{cap:02}, verrà fornita una panoramica sul linguaggio di programmazione Rust, con particolare attenzione sulle motivazioni 
che ne hanno determinato lo sviluppo e che sono alla base della sua crescente popolarità negli ultimi anni. \hfill
\vspace{7pt}\\
\noindent Nel Capitolo~\ref{cap:03}, verrà esaminato il modello di gestione della memoria implementato da Rust,
con un'analisi approfondita dei meccanismi alla base; verranno inoltre forniti listati di codice che mostrano esempi del loro funzionamento. \hfill
\vspace{7pt}\\
\noindent Nel Capitolo~\ref{cap:04}, verranno esposti gli strumenti necessari che un linguaggio di programmazione dovrebbe avere per essere impiegato 
nella programmazione di sistema, con riferimento al linguaggio C. 
Successivamente, quest'ultimo verrà confrontato con Rust sotto gli aspetti di 
gestione della memoria, delle risorse e degli errori, complessità del codice e prestazioni, per mostrare come Rust metta a disposizione strumenti 
fondamentali per essere considerato una valida alternativa, teorica, nella programmazione di sistema. \hfill
\vspace{7pt}\\
\noindent Infine, nel Capitolo~\ref{cap:05}, verranno presentati progetti e applicazioni concreti che mostrano, nella pratica, come 
Rust non sia solo un linguaggio promettente dal punto di vista teorico, ma rappresenti un valido strumento, capace di ottenere risultati concreti, nella programmazione di basso livello.

\section{Annuncio dei risultati}
Nella prima parte della tesi (Capitolo~\ref{cap:02}, Capitolo~\ref{cap:03} e Capitolo~\ref{cap:04}), viene evidenziato come l'approccio di gestione della memoria di Rust permetta 
di prevenire errori critici tipici dei linguaggi con approccio manuale, senza compromettere le prestazioni.

Il confronto con C evidenzia vantaggi in termini di sicurezza e mantenibilità, a fronte di una sintassi più complessa 
e una curva di apprendimento più ripida e lenta. \hfill 
\vspace{8pt}\\
\noindent Nella seconda parte (Capitolo~\ref{cap:05}), verranno presi in considerazioni progetti concreti (\textit{Rust for Linux}, \textit{Redox OS}, il kernel di Windows 11 e \texttt{sudo-rs}), 
evidenziando che Rust è già impiegato in contesti di sistemi operativi e che la sua adozione procede, seppur gradualmente, in maniera significativa.