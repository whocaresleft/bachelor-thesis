% !TEX root = ../Thesis.tex

\chapter{Sistemi Operativi}\label{cap:04}

Questo capitolo esplorerà le capacità offerte da Rust nel 
contesto della programmazione di sistema. In apertura verrà
fornita una panoramica sul linguaggio C, standard \textit{de facto}
nel contesto programmazione di sistema, con particolare attenzione alle 
 caratteristiche che lo rendono popolare in questo ambito.

Successivamente Rust verrà confrontato con C rispetto agli aspetti analizzati
, per valutare come Rust possa presentare un'alternativa valida sul piano teorico.

Nel capitolo~\ref{cap:05}, `\textit{<inserire nome>}', l'analisi verrà spostata sul piano pratico, 
esplorando progetti concreti, che mostrano le potenzialità di Rust nella programmazione di basso livello. \hfill
\vspace{20pt}\\
\noindent Nel contesto dei sistemi operativi, quali lo sviluppo di kernel, driver o componenti embedded i linguaggi tradizionalmente dominanti
 sono l'assembly e, con maggiore rilievo, C.

Nonostante l'esistenza di alternative come C++, Lisp, Forth o Bliss, la scelta spesso ricave esclusivamente
su C, come testimoniano le codebase dei sistemi operativi più popolari oggi giorno: Windows, MacOS, Linux e Android sono scritti quasi interamente nel linguaggio C.

Ma cosa rende C così popolare in questo ambito? Quali caratteristiche lo distinguono dalle alternative?

\section{C:\  motivazioni e caratteristiche}
C è un linguaggio di programmazione ampiamente utilizzato nella 
programmazione di sistema. Il linguaggio offre un livello
di astrazione molto vicino al codice macchina (o meglio, 
all'assembly), garantendo un certo grado di portabilità 
tra architetture differenti.

Si consideri, per esempio, quanto detto dal creatore del linguaggio:
\begin{center}
    \begin{minipage}{0.9\textwidth}
        \vspace{0.5em}
        \itshape "[C has] the power of the assembly language and the convenience of \ldots assembly language."

        \hfill --- Dennis Ritchie, creatore del linguaggio C, "Dennis Ritchie: The Shoulders Steve Jobs Stood On", *Wired*, 13 Oct 2011
        \vspace{0.4em}
    \end{minipage}
\end{center}
\noindent La popolarità di C in questo ambito è da attribuire a
diverse sue caratteristiche, alcune delle quali ben documentate\cite{c-system-programming-why}. 
Queste sono principalmente: compilazione, assenza di dipendenze 
runtime, gestione diretta della memoria, manipolazione 
a basso livello di bit e corrispondenza quasi diretta al codice macchina.

\subsection*{Compilazione}
C è un linguaggio compilato: il file eseguibile generato risulta 
molto efficiente, sotto l'aspetto della velocità d'esecuzione, 
rispetto a linguaggi interpretati. Questo lo rende preferibile nell'ambito di sviluppo
kernel, dove le prestazioni rappresentano un aspetto cruciale.

\subsection*{Assenza di dipendenze runtime}
C può essere impiegato per realizzare codice 
`\textit{bare metal}', eseguibile direttamente sull'hardware, 
senza il supporto di un sistema operativo. 

C non ha esigenze runtime significative: può funzionare anche senza un allocatore di memoria fornito dal 
sistema operativo\footnote{Un programma che non usufruisce della memoria 
dinamica non richiede un allocatore. Inoltre, nello sviluppo di un sistema 
operativo, è il programmatore che deve fornire il proprio sistema di allocazione.}. L'unica 
necessità minima è quella di un chiamante che invochi la funzione \textit{main}\footnote{In contesti a basso livello, quest a chiamata 
 può essere realizzata da codice assembly.}.

\subsection*{Accesso diretto alla memoria}
I puntatori C consentono l'accesso diretto a
indirizzi di memoria arbitrari, permettendo operazioni di lettura e 
scrittura dirette. 

Tale controllo sulla memoria è cruciale per lo sviluppo di un 
sistema operativo, dove è richiesto di gestire: tabelle delle pagine, dispositivi I/O mappati sulla memoria, controllori DMA e altri;

\subsection*{Manipolazione di bit}
Molte interazioni con l'hardware avvengono tramite operazioni bitwise, come riportato da \textit{Ada Computers}\cite{bitwise-operations}. 
Esempi comuni sono:
\begin{itemize}
    \item Operazioni di scrittura e lettura dei registri della CPU, come registri di flag di stato. Per esempio, in CPU x86 si trova il registro \textit{EFLAGS} che contiene una serie di bit di stato (\textit{overflow}, \textit{zero}, \textit{carry}, \textit{interrupt enable} e altri), il loro controllo di solito è fatto tramite l'applicazione di una maschera bitwise;
    \item Gestione delle periferiche mappate sulla memoria, tramite operazioni di abilitazione e disabilitazione dei singoli pin (e.g.\  registri \textit{GPIO});
    \item Il clock della CPU può essere gestito tramite operazioni bitwise.
\end{itemize}
Come riportato dal seguente articolo~\cite{bitwise-operations-c}, il linguaggio C supporta un ampio range di operazioni bitwise, offrendo i seguenti operatori: \textit{AND}, \textit{OR}, \textit{XOR}, \textit{SHL}, \textit{SHR}, \textit{NOT} e il complemento.

\subsection*{Somiglianza al codice macchina}
C mantiene una corrispondenza quasi \textit{1-to-1} in codice assembly. 
Questa trasparenza del linguaggio è fondamentale nello sviluppo di 
sistemi operativi, in quanto consente di comprendere l'effetto di ogni singola istruzione. 
C evita strutture dati complesse o astrazioni pesanti che potrebbero mascherare
il comportamento a basso livello del programma.\hfill
\vspace{30pt}\\
\noindent Tuttavia, uno dei punti di forza di C rappresenta anche una sua criticità. 
L'accesso diretto e non controllato della memoria, unito all'assenza di protezioni a runtime, rende semplice
commettere errori potenzialmente gravi come:
\begin{itemize}
    \item \textbf{Accessi non autorizzati alla memoria}: un programma che legge da un indirizzo di memoria arbitrario potrebbe inavvertitamente compromettere la privacy di un'altro processo; una scrittura accidentale potrebbe causare la corruzione della memoria, condivisa o utilizzata da un altro processo;
    \item \textbf{Saturazione della memoria}: un programma che alloca memoria senza controllo o limiti potrebbe esaurire la memoria disponibile. Se lo \textit{swapping} è disponibile, il sistema può degradare drasticamente le prestazioni; in caso non lo fosse, può verificarsi un crash.
\end{itemize}

\section{Rust contro C}
Nonostante Rust offra numerose astrazioni di alto livello\footnote{Rust offre delle astrazioni di alto livello definite \textit{zero cost}: feature quali \textit{iteratori}, \textit{generics}, \textit{smart pointers} e meccanismi di \textit{async/await} che vengono compilate in codice dalle prestazioni equivalenti alla controparte \textit{low-level} scritta a mano.}, è progettato come un linguaggio di basso livello, 
adatto alla programmazione di sistema.
Per comprendere le capacità di Rust nella programmazione di basso livello, verrà confrontato con il linguaggio C, sulla 
base delle caratteristiche che lo rendono favorevole nella programmazione di sistema.

La maggior parte delle informazioni riportate nella sezione è stata ricavata dalla documentazione ufficiale di Rust\cite{rust-book}.
\begin{itemize}
    \item \textbf{Compilazione} (Come C): Anche Rust è un linguaggio compilato. Il compilatore genera, in base alla piattaforma, un file direttamente eseguibile;
    \item \textbf{Dipendenze runtime} (Come C): Rust, per configurazione predefinita, ha dipendenze runtime minime (principalmente un allocatore di memoria). Tuttavia, come riportato in \textit{The Embedded Rust Book}\cite{rust-book-embedded}, tramite la direttiva \texttt{\#![no\_std]} è possibile escludere la libreria standard: in questa configurazione, l'unico requisito è un bootstrap che invochi la funzione \texttt{\_start} per fare iniziare l'esecuzione;
    \item \textbf{Accesso diretto alla memoria} (Come C): Tramite una parola chiave, \textit{unsafe}, Rust mette a disposizione cinque operazioni denominate \textit{superpoteri non sicuri}: tra queste si trovano anche la possibilità di dereferenziare un puntatore raw (come in C) e la possiblità di eseguire codice C o assembly;
    \item \textbf{Manipolazione di bit} (Come C): Rust offre lo stesso livello di manipolazione dei singoli bit di C, con un'unica differenza: le operazioni bitwise in Rust sono ben definite, evitando condizioni di \textit{Undefined Behaviour} tramite controlli statici sulle dimensione e tipi degli operandi;
    \item \textbf{Somiglianza al codice macchina} (Diverso da C): Rust generalmente offre astrazioni di alto livello, inoltre il compilatore può introdurre copie e spostamenti aggiuntivi per preservare le condizioni di ownership o inserire controlli su accessi e indici per gli \textit{slice}\footnote{Slice è un tipo primitivo in Rust. Sono un riferimento a una porzione contigua (in memoria) di elementi di una collezione. Non memorizzano dati esplicitamente, si tratta di una vista su dati esistenti.}. Tali comportamenti, pur aumentando la sicurezza, possono produrre un codice meno `trasparente' rispetto alla controparte C;\ 
\end{itemize}
Infine, a differenza di C, Rust garantisce l'integrità e la sicurezza della memoria già a tempo della compilazione, prevenendo 
errori comuni legati alla gestione della memoria grazie al \textit{modello di ownership}. In quanto i controlli effettuati
dal \textit{Borrow Checker} avvengono a tempo di compilazione non si hanno dipendenze o overhead introdotti a runtime.

\subsection*{Unsafe Rust}
Come già accennato, Rust mette a disposizione, tramite la parola chiave \textit{unsafe}, cinque operazioni principali. Gli sviluppatori
del progetto Rust si riferiscono a queste operazioni con l'espressione \textit{Unsafe Superpowers}:
\begin{itemize}
    \item Dereference di un puntatore raw;
    \item Invocazione di una funzione o metodo non sicuri;
    \item Accesso e modifica di una variabile mutabile e statica;
    \item Implementazione di un tratto non sicuro;
    \item Accesso ai campi di una \textit{union}.
\end{itemize}
Le espressioni \textit{Unsafe Rust} e \textit{Unsafe Superpowers} possono risultare fuorvianti: il \textit{Borrow Checker} esegue 
comunque controlli per garantire la validità delle reference. 

La parola chiave permette solamente di eseguire operazioni che, per definizione, sono considerate non sicure. 
Il compilatore non può controllarne la sicurezza e l'integrità durante la compilazione; all'interno di un blocco
 \textit{unsafe}, è il programmatore a diventare responsabile di garantire che gli accessi alla memoria
siano validi. \hfill
\vspace{12pt}\\
\noindent La \textit{best practice} riguardante i blocchi non sicuri prevede di ridurre il codice non sicuro il più possibile, utilizzandolo solo quando stretto necessario.
Inoltre, è preferito incapsulare il codice non sicuro all'interno di un'astrazione sicura, fornendo una API sicura per il suo utilizzo. \hfill
\subsection{Gestione delle risorse}
\subsection{Sicurezza della memoria}
In questa sottosezione verranno analizzati alcuni tra gli errori più comuni legati alla gestione della memoria,
mostrando esempi di codice scritti in C e confrontandoli, quando possibile, con le controparti in Rust.

Un aspetto interessante del modello di memoria di Rust è che alcuni errori non sono semplicemente rilevati
durante l'esecuzione, o a tempo di compilazione, ma sono strutturalmente impossibili da generare: non vi è modo di scrivere codice Rust che generi tali errori.
Come già accennato, il \textit{modello di ownership} guida la struttura di un programma in Rust: spinge il programmatore a
ragionare in termini di \textit{ownership} e \textit{lifetime}. Inoltre, l'allocazione della memoria dinamica è gestita tramite l'utilizzo
di \textit{smart pointers}, che forniscono un'astrazione sicura per la gestione della memoria dinamica.

% Unfreed memory
\subsubsection{Unfreed memory}
La \textit{unfreed memory} (memoria non liberata) rappresenta un errore comune durante la gestione della memoria dinamica tramite approccio manuale.
Si ha in quei contesti in cui aree di memoria vengono allocate, senza successiva deallocazione. Le aree di memoria interessate non
possono essere riutilizzate per allocazioni successive in quanto vengono considerate ancora utilizzate.

Si consideri il seguente esempio minimale C che genera un'errore di \textit{unfreed memory}:
\begin{lstlisting}[language=C, caption={Unfreed memory in C}, label={c:unfreed-memory}]
#include <stdlib.h>
int main(void) {
    void* mem = malloc(sizeof(int));
    return 0;
}
\end{lstlisting}
In Rust questo comportamento non si potrà mai realizzare, in quanto la deallocazione viene gestita implicitamente dal compilatore\footnote{Il compilatore inserisce chiamate alla funzione \textit{drop} in corrispondenza della fine di uno scope. Questo è realizzabile in quanto il \textit{Borrow Checker} controlla le relazioni di \textit{ownership} e \textit{borrowing} per determinare chi sia responsabile della deallocazione, ovvero su quali variabili invocare \textit{drop}.}. \hfill

\noindent Si consideri un programma in Rust che, per quanto possibile, replica il comportamento del listato~\ref{c:unfreed-memory}:
\begin{lstlisting}[language=Rust, caption={Unfreed memory in Rust}, label={rust:unfreed-memory}]
fn main() {
    let mem = Box::<u32>::new(0);
}
\end{lstlisting}
Nel listato~\ref{c:unfreed-memory} viene allocata memoria nella heap sufficiente a contenere un intero, successivamente 
il programma termina senza liberarla\footnote{In realtà l'allocazione avviene nello spazio di memoria virtuale del processo; a termine dell'esecuzione, il sistema operativo recupera tutte le risorse allocate dal processo.}. 
Il programma viene compilato ed eseguito correttamente, 
nonostante la presenza di questo errore. 
Tuttavia, tale memoria risulta inaccessibile per ulteriori allocazioni da parte del processo durante la sua esecuzione.\hfill
\vspace{10pt}\\
\noindent Il listato~\ref{rust:unfreed-memory} rappresenta il codice Rust più vicino possibile a 
quello riportato nel listato~\ref{c:unfreed-memory}. La differenza principale è che la memoria viene deallocata automaticamente: 
al termine dello scope della funzione \texttt{main}, la variabile \texttt{mem} viene eliminata e la relativa 
memoria deallocata. 

Di conseguenza, l'errore di \textit{unfreed memory} non può manifestarsi, in quanto la deallocazione avviene in maniera 
trasparente agli occhi del programmatore. 


% Double free
\subsubsection{Double free}
La \textit{double free} (doppia liberazione) è un'errore di gestione della memoria che si verifica quando la stessa area di memoria viene deallocata
più di una volta. Ciò può causare la corruzione della memoria heap, con conseguente comportamento indefinito o crash del programma.

Nel linguaggio C, questo si verifica invocando la funzione \texttt{free} sullo stesso puntatore più volte, come mostrato 
nel seguente esempio:
\begin{samepage}
\begin{lstlisting}[language=C, caption={Double free in C}, label={c:double-free}]
#include <stdlib.h>
int main(void) {
    void* ptr = malloc(sizeof(int));
    free(ptr);
    free(ptr);
    return 0;
}
\end{lstlisting}
\end{samepage}
Si consideri invece il seguente programma Rust che tenta di replicare lo stesso comportamento del listato~\ref{c:double-free}:
\begin{lstlisting}[language=Rust, caption={Double free in Rust}, label={rust:double-free}]
fn main() {
    let mem = Box::<u32>::new(0);
    std::mem::drop(mem);
    std::mem::drop(mem);
}
\end{lstlisting}
Nel listato~\ref{c:double-free} la memoria puntata da \texttt{ptr} viene deallocata due volte.
In fase di esecuzione questo può portare a un crash del programma, come mostrato nell'immagine~\ref{c:double-free-exec}.

Tuttavia, lo standard C non definisce un comportamento specifico da adottare in questo contesto, causando 
\textit{undefined behaviour} nella pratica\footnote{In ambiente Linux con \texttt{glibc}, viene rilevato l'errore causando
 la stampa di un messaggio e l'interruzione dell'esecuzione. In ambienti Windows, l'errore può passare inosservato o causare un crash silenzioso.}.

Per quanto riguarda Rust, è possibile considerare due scenari: 
\begin{itemize}
    \item Il listato~\ref{rust:unfreed-memory} rappresenta il comportamento idiomatico di Rust: la memoria viene deallocata automaticamente alla fine di uno \textit{scope}, senza necessità di interventi manuali;
    \item Nel listato~\ref{rust:double-free}, invece, si tenta di deallocare esplicitamente la memoria con due chiamate consecutive a \texttt{std::mem::drop}\footnote{Questa funzione assume \textit{ownership} del valore fornito, causandone la deallocazione una volta raggiunta la fine della funzione.}. Tuttavia, la funzione \texttt{drop} prende possesso del valore, rendendo la reference originale, e di conseguenza la seconda chiamata, invalida. Il compilatore si accorge della violazione della terza regola di \textit{borrowing} (\textit{Tutte le reference devono essere valide}), impedendo la compilazione e generando l'errore riportato nell'immagine~\ref{rust:double-free-compile}.
\end{itemize}
\begin{figure}[htbp]
\begin{center}
    \includegraphics[width=.8\textwidth]{double-free-c-exec}
    \caption{\textit{Double free} in C}\label{c:double-free-exec}
    \end{center}
\end{figure}
\begin{figure}[htbp]
\begin{center}
    \includegraphics[width=.8\textwidth]{double-free-rust-compile}
    \caption{Tentativo di \textit{double free} in Rust}\label{rust:double-free-compile}
    \end{center}
\end{figure}

% Dangling pointer
\subsubsection{Dangling pointers}
Un \textit{dangling pointer} (puntatore pendente) è un puntatore che riferisce a una locazione di memoria non più valida o che è stata liberata. 
Generalmente si presenta quando un'area di memoria viene deallocata, ma gli eventuali puntatori che la referenziavano non vengono aggiornati.

Si consideri il seguente esempio C che genera un \textit{dangling pointer}\footnote{La presenza di uno scope interno non è funzionale all'esempio, ma non ne modifica nemmeno il risultato. È presente per garantire somiglianza strutturale con l'esempio Rust successivo.}:
\begin{lstlisting}[language=C, caption={Dangling pointer in C}, label={c:dangling-pointer}]
int main(void) {
    int* ptr;
    {
        int* val = malloc(sizeof(int));
        *val = 30;
        ptr = val;
        free(val);
    }
}
\end{lstlisting}
Nel listato~\ref{c:dangling-pointer}, viene allocata memoria sufficiente per un intero e il suo indirizzo è memorizzato 
sia in \texttt{val} che in \texttt{ptr}. La memoria viene successivamente deallocata invocando la funzione \texttt{free} sul puntatore \texttt{val}.
Tuttavia, il puntatore \texttt{ptr} non viene aggiornato, continuando a riferire alla stessa area di memoria, ormai non più valida.

È importante osservare che la sola esistenza un un \textit{dangling pointer} non causa un errore immediato.
Il comportamento indefinito si manifesta solo quando si tenta di derefenziare tale puntatore, cercando di leggere o scrivere nella memoria a cui fa riferimento. \hfill
\vspace{12pt}\\
\noindent A dimostrazione di ciò, si consideri che Rust permette la creazione di una \textit{dangling reference}, a patto che non venga utilizzata.
Il seguente esempio mostra questa possibilità:
\begin{lstlisting}[language=Rust, caption={Dangling reference in Rust}, label={rust:dangling-pointer}]
fn main() {
    let _ref: &u32;
    {
        let val = Box::<u32>::new(30);
        _ref = &*val;
    }
}
\end{lstlisting}
Il listato~\ref{rust:dangling-pointer} tenta di replicare, per quanto possibile, il comportamento descritto nel listato~\ref{c:dangling-pointer}:
alla variabile \texttt{\_ref} viene assegnato un riferimento a \texttt{val}, allocata dinamicamente in uno scope interno. All'uscita 
da tale scope, \texttt{val} viene deallocato, lasciando \texttt{\_ref} con un riferimento non valido. 

Nonostante ciò, il compilatore non genera alcun errore.
Questo comportamento è giustificato dal fatto che la reference non è mai utilizzata\footnote{Il \textit{Borrow Checker} lavora in maniera \textit{lazy}: non verifica 
le condizioni di \textit{borrowing} e \textit{lifetime} di una reference fino a che non viene utilizzata.} e, di conseguenza, il \textit{Borrow Checker} non rileva alcuna
 violazione delle regole di \textit{borrowing}.

% Access after free
\subsubsection{Access after free}
Sebbene la sola presenza di un \textit{dangling pointer} non causi immediatamente problemi, essa rappresenta una condizione necessaria 
per un errore più grave: la \textit{access after free} (accesso post-liberazione).
Questo errore si verifica quando si tenta di accedere a memoria precedentemente deallocata, dereferenziando un \textit{dangling pointer}. 

A seconda del tipo
di accesso, si possono avere conseguenze differenti:
\begin{itemize}
    \item \textbf{Lettura}: può causare il recupero di dati non validi o incoerenti, eventualmente sovrascritti da allocazioni successive;
    \item \textbf{Scrittura}: può compromettere l'integrità della memoria, causando comportamenti indefiniti o crash del programma.
\end{itemize}
Si consideri il seguente esempio C che, estendendo il listato~\ref{c:dangling-pointer}, genera un errore di \textit{access after free}:
\begin{lstlisting}[language=C, caption={Access after free in C}, label={c:access-after-free}]
#include <stdlib.h>
#include <stdio.h>
int main(void) {
    int* ptr;
    {
        int* val = malloc(sizeof(int));
        *val = 30;
        ptr = val;
        free(val);
    }
    printf("%d\n", *ptr);
}
\end{lstlisting}
Nel listato~\ref{c:access-after-free} si tenta di dereferenziare il puntatore \texttt{ptr} dopo che la memoria a cui faceva riferimento è stata deallocata.
In questo caso, l'accesso avviene per effettuare un'operazione di lettura, che rappresenta una forma
 meno distruttiva rispetto a una scrittura, ma che resta comunque pericolosa:
i dati letti potrebbero essere non validi o casuali, in quanto la memoria potrebbe essere stata sovrascritta da allocazioni successive.
 
Questo comportamento rappresenta un esempio di \textit{undefined behaviour}, come illustrato
dall'immagine~\ref{c:access-after-free-exec}. \hfill
\vspace{12pt}\\
\noindent Per osservare come Rust gestisce questa problematica, si consideri il seguente esempio, il quale estende il listato~\ref{rust:dangling-pointer}:
\begin{lstlisting}[language=Rust, caption={Tentativo di access after free in Rust}, label={rust:access-after-free}]
fn main() {
    let _ref: &u32;
    {
        let val = Box::<u32>::new(30);
        _ref = &*val;
    }
    println!("{}", _ref);
}
\end{lstlisting}
Il listato~\ref{rust:dangling-pointer} tenta di replicare il comportamento del listato~\ref{c:access-after-free}, cercando 
di accedere a una reference pendente per un'operazione di lettura.

Tuttavia, in questo caso viene generato un errore di compilazione, come mostrato nell'immagine~\ref{rust:access-after-free-compile}.
Il \textit{Borrow Checker} rileva che \texttt{\_ref} viene utilizzata successivamente alla deallocazione di \texttt{val}, rappresentando una violazione 
delle regole di \textit{borrowing} e, di conseguenza, impedisce la compilazione.
\begin{figure}[htbp]
\begin{center}
    \includegraphics[width=.8\textwidth]{access-after-free-c-exec}
    \caption{\textit{Access after free} in C}\label{c:access-after-free-exec}
    \end{center}
\end{figure}
\begin{figure}[htbp]
\begin{center}
    \includegraphics[width=.8\textwidth]{access-after-free-rust-compile}
    \caption{Tentativo di \textit{access after free} in Rust}\label{rust:access-after-free-compile}
    \end{center}
\end{figure}

% Buffer Overflow e Overread
\subsubsection{Access out of bounds: buffer overflow e overread}
L' \textit{access out of bounds} è un errore comune associatio alla gestione manuale della memoria dinamica.
Si verifica quando si tenta di accedere a una porzione di memoria al di fuori dei limiti dell'area effettivamente allocata.

In base al tipo di accesso si distingue in due varianti: nel caso di una lettura si parla di \textit{buffer overread} 
(lettura oltre i limiti) mentre, nel caso di una scrittura, di \textit{buffer overflow} (sovraccarico o sovrascrittura del buffer).

\paragraph{Buffer overflow}
Si consideri il seguente esempio C che genera un errore di \textit{buffer overflow}:
\begin{lstlisting}[language=C, caption={Buffer overflow in C}, label={c:buffer-overflow}]
#include <stdlib.h>
#include <stdio.h>
int main(void) {
    int* vec = malloc(sizeof(int) * 3);
    printf("Allocato un vettore di 3 interi, indici validi: 0, 1, 2\n");
    for(int i = 0; i <= 3; i++) {
        printf("Memorizzando %d all'indice %d\n", i * 10, i);
        vec[i] = i * 10;
    }
    free(vec);
    printf("Terminata la memorizzazione!\n");
    return 0;
}
\end{lstlisting}
Nel listato~\ref{c:buffer-overflow} viene allocata memoria suffiente per un vettore di tre interi, ma successivamente vengono
inizializzati quattro elementi, dall'indice \texttt{0} fino a \texttt{3}.
In questo caso il programma termina senza errori, viene anche eseguita la stampa finale, come mostrato dall'immagine~\ref{c:buffer-overflow-exec}. 

Nonostante ciò, questo comportamento non può essere considerato una garanzia in quanto, generalmente, la conseguenza di un \textit{buffer overflow} è un \textit{undefined behaviour}: 
non è possibile determinare a priori cosa contenga la memoria oltre
il limite dell'allocazione o per cosa venga utilizzata\footnote{In generale un \textit{buffer overflow} avviene all'interno dello spazio
di indirizzamento virtuale di un processo. In questo caso, la memoria potenzialmente corrotta sarebbe
 del processo stesso. Tuttavia, nel caso in cui l'indirizzo di riferimento
 fosse al di fuori dello spazio di indirizzamento virtuale del processo verrebbe generato un'errore runtime di tipo \textit{segmentation fault}, 
 causando l'immediato crash del programma.}. \hfill
\vspace{10pt}\\
\noindent Per comprendere come Rust gestisca questo errore, si consideri il seguente esempio:
\begin{lstlisting}[language=Rust, caption={Buffer overflow in Rust}, label={rust:buffer-overflow}]
fn main() {
    let mut vec: Vec<u32> = vec![0; 3];
    println!("Allocato un vettore di 3 interi, indici validi: 0, 1, 2");
    for i in 0u32..=3u32 {    
        println!("Memorizzando {} all'indice {}", i * 10, i);
        vec[i as usize] = i * 10;
    }
    println!("Terminata la memorizzazione!");
}
\end{lstlisting}
Il listato~\ref{rust:buffer-overflow} tenta di replicare il comportamento del listato~\ref{c:buffer-overflow}, 
allocando un vettore di tre interi e successivamente cercando di inizializzarne quattro. 
In questo caso la compilazione va a buon fine, ma la stampa finale non avviene: il programma genera un \textit{panic} durante l'esecuzione. Questo avviene
durante l'accesso all'indice \texttt{3}, come mostrato nell'immagine~\ref{rust:buffer-overflow-exec}.

Questo comportamento è dovuto al fatto che il compilatore inserisce controlli di validità sugli indici, i quali vengono eseguiti a runtime.\footnote{Infatti, il compilatore non può sapere a tempo di compilazione quali sarnno gli indice che verranno utilizzati per accedere a un vettore, quindi si limita a inserire controlli sulla loro validità prima degli accessi effettivi.}
\begin{figure}[htbp]
\begin{center}
    \includegraphics[width=.8\textwidth]{c-buffer-overflow-exec}
    \caption{\textit{Buffer overflow} in C}\label{c:buffer-overflow-exec}
    \end{center}
\end{figure}
\begin{figure}[htbp]
\begin{center}
    \includegraphics[width=.8\textwidth]{rust-buffer-overflow-exec}
    \caption{\textit{Buffer overflow} in Rust}\label{rust:buffer-overflow-exec}
    \end{center}
\end{figure}


\paragraph{Buffer overread}
Si consideri il seguente esempio C che genera un errore di \textit{buffer overread}:
\begin{lstlisting}[language=C, caption={Buffer overread in C}, label={c:buffer-overread}]
#include <stdlib.h>
#include <stdio.h>
int main(void) {
    int* vec = malloc(sizeof(int) * 3);
    for(int i = 0; i < 3; i++) vec[i] = i * 10;
    printf("Contenuto del vettore:\n");
    for(int i = 0; i < 10; i++)
        printf("Indice: %d -> Valore: %d\n", i, vec[i]);
    free(vec);
    return 0;
}
\end{lstlisting}
Nel listato~\ref{c:buffer-overread} viene allocata memoria per un vettore di tre interi, i quali vengono correttamente inizializzati e, successivamente,
si tenta di leggere dieci elementi dal vettore.
In questo caso il programma termina senza errori, stampando effettivamente dieci elementi, come mostrato dall'immagine~\ref{c:buffer-overread-exec}. 

Come quanto detto per l'errore di \textit{buffer overflow}, generalmente la conseguenza è un \textit{undefined behaviour}: 
non è possibile determinare a priori cosa contenga la memoria (oltre
il limite dell'allocazione) che viene letta\footnote{Vangono le stesse considerazioni fatte per il \textit{buffer overflow}: un'accesso a un indirizzo
che eccede lo spazio di indirizzi virtuali del processo genera un errore runtime di tipo \textit{segmentation fault}, causando l'immediato crash del programma}.\hfill
\vspace{10pt}\\
\noindent Rust gestisce questo errore in maniera analoga al \textit{buffer overflow}. Si consideri a dimostrazione di ciò il seguente esempio:
\begin{lstlisting}[language=Rust, caption={Buffer overread in Rust}, label={rust:buffer-overread}]
fn main() {
    fn main() {
    let vec: Vec<u32> = vec![0, 10, 20];
    println!("Contenuto del vettore:");
    for i in 0..10 {
        println!("Indice: {} -> Valore: {}", i, vec[i]);
    }
}
}
\end{lstlisting}
Il listato~\ref{rust:buffer-overread} tenta di replicare il comportamento del listato~\ref{c:buffer-overread}, 
allocando un vettore di tre interi e successivamente cercando di leggerne dieci. 

Anche in questo caso la compilazione termina correttamente ma, durante l'esecuzione, in particolare durante l'accesso al quarto elemento, viene generato
un \textit{panic}. 

Questo comportamento può essere osservato nell'immagine~\ref{rust:buffer-overread-exec}.
\begin{figure}[htbp]
\begin{center}
    \includegraphics[width=.8\textwidth]{c-buffer-overread-exec}
    \caption{\textit{Buffer overread} in C}\label{c:buffer-overread-exec}
    \end{center}
\end{figure}
\begin{figure}[htbp]
\begin{center}
    \includegraphics[width=.8\textwidth]{rust-buffer-overread-exec}
    \caption{\textit{Buffer overread} in Rust}\label{rust:buffer-overread-exec}
    \end{center}
\end{figure}

% Unitialized memory access
\subsubsection{Unitialized memory access} 
La \textit{unitialized memory access} (accesso a memoria non inizializzata) è un errore che si presenta
 quando si tenta di leggere da un'area di memoria che non è stata 
 inizializzata. Questo può portare a comportamenti imprevedibili, in quanto 
 i dati letti potrebbero essere casuali e potenzialmente 
 residui da allocazioni precedenti.

Nel linguaggio C, questo errore si presenta tipicamente quando viene 
allocata memoria tramite la funzione \texttt{malloc} e successivamente si tenta di 
accedervi senza previa inizializzazione.

Si consideri il seguente esempio C che genera un errore di questo tipo:
\begin{lstlisting}[language=C, caption={Uninitialized memory access in C}, label={c:uninitialized-memory-access}]
#include <stdlib.h>
#include <stdio.h>
int main(void) {
    int* ptr = malloc(sizeof(int));
    printf("%d\n", *ptr);
    free(ptr);
    return 0;
}
\end{lstlisting}
Nel listato~\ref{c:uninitialized-memory-access} viene allocata memoria sufficiente a contenere un intero e, senza inizializzarne il contenuto,
viene tentato un accesso in lettura. 
Il risultato è un comportamento indefinito: il valore letto potrebbe variare in base all'ambiente di esecuzione e tra esecuzioni, senza garanzia di coerenza.

È possibile osservare un caso particolare, in cui l'accesso può sembrare produrre un risultato coerente, come mostrato nell'immagine~\ref{c:uninitialized-memory-access-exec}\footnote{L'esecuzione è avvenuta su Ubuntu LTS 24.04 con \texttt{glibc}. In questo contesto è possibile che \texttt{malloc} azzeri la memoria allocata, prima di restituirne l'indirizzo, ma non è un comportamento garantito dallo standard C.}.
Tuttavia, questa apparente stabilità non può essere considerata una garanzia, in quanto vi sono più fattori che possono influenzare il valore letto:
\begin{itemize}
    \item Implementazioni specifiche dell'allocatore di memoria, che possono inizializzare la memoria allocata a zero o a un valore casuale;
    \item La posizione in memoria scelta dall'allocatore per il puntatore;
    \item Eventuali valori residui da allocazioni precedenti;
    \item La mappatura tra pagine virtuali e fisiche da parte del sistema operativo.
\end{itemize}
A conferma dell'inaffidabilità, si consideri il seguente esempio, che estende il listato~\ref{c:uninitialized-memory-access}: 
\begin{lstlisting}[language=C, caption={Uninitialized memory access in C}, label={c:uninitialized-memory-access-2}]
#include <stdlib.h>
#include <stdio.h>
int main(void) {
    int* ptr = malloc(sizeof(int));
    free(ptr);
    ptr = malloc(sizeof(int));
    printf("%d\n", *ptr);
    free(ptr);
    return 0;
}
\end{lstlisting}
Il listato~\ref{c:uninitialized-memory-access-2} mostra come eseguire una \texttt{free} prima della \texttt{malloc} successiva può lasciare residui nella memoria. 
Di conseguenza il valore letto, questa volta, è diverso da zero, come si può osservare dall'immagine~\ref{c:uninitialized-memory-access-exec-2}\footnote{Anche in questo caso, si tratta di un comportamento specifico del sistema e non garantito dallo standard}.
\begin{figure}[htbp]
\begin{center}
    \includegraphics[width=.6\textwidth]{c-uninitialized-memory-access-exec}
    \caption{\textit{Uninitialized memory access in C} in C}\label{c:uninitialized-memory-access-exec}
    \end{center}
\end{figure}
Rust previene questa problematica in maniera strutturale, non permettendo allocazioni dinamiche senza inizializzazione grazie all'utilizzo di \texttt{smart pointers}, i quali prevedono un'inizializzazione obbligatoria.

In Rust infatti, le principali primitive per l'allocazione dinamica richiedono sempre l'inizializzazione dei valori:
\begin{itemize}
    \item \texttt{Box}: \textit{smart pointer} impiegato per allocare un singolo valore nella heap. L'unico modo per crearne uno è tramite \texttt{Box::new}, che richiede un valore per l'inizializzazione. In \textit{safe} Rust, non esiste un costrutto equivalente alla \texttt{malloc} in C;\ 
    \item \texttt{Vec}: \textit{smart pointer} utilizzato per una collezione dinamica di valori in heap. Anche se può essere creato vuoto (\texttt{Vec::new}), ogni accesso è verificato a runtime per evitare accessi oltre i limiti. In caso di violazioni viene generato un \texttt{panic}, terminando l'esecuzione, come è osservabile nell'immagine [mettere sopra];
\end{itemize}
Di conseguenza, non è possibile sviluppare codice Rust che acceda a memoria non inizializzata senza ricorrere alla parola chiave \texttt{unsafe}\footnote{Rust consente l'accesso a memoria potenzialmente non inizializzata, ma soltanto all'interno di blocchi \textit{unsafe}. Un esempio è la funzione \texttt{std::mem::MaybeUninit}, ma meccanismi come questo sono riservati a casi particolari, in cui le garanzie di sicurezza devono essere gestite manualmente dal programmatore.}.
\begin{figure}[htbp]
\begin{center}
    \includegraphics[width=.6\textwidth]{c-uninitialized-memory-access-exec-2}
    \caption{\textit{Uninitialized memory access in C con previa free} in C}\label{c:uninitialized-memory-access-exec-2}
    \end{center}
\end{figure}

\subsubsection{Sicurezza della memoria: conclusioni}
In conclusione, sotto l'aspetto della sicurezza della memoria, Rust si distingue da C garantendo un comportamento sicuro e deterministico, prevenendo
alcuni errori durante la compilazione e rilevandone altri a runtime. In C, d'altra parte, tali errori possono passare inosservati, causando
\textit{undefined behaviour} o crash del programma.


\subsection{Prestazioni}
\subsection{Complessità del codice}
