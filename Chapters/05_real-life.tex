% !TEX root = ../Thesis.tex

\chapter{Progetti e applicazioni reali}\label{cap:05}

In questo capitolo verranno presentati progetti concreti che dimostrano
come Rust possa costituire una scelta valida non solo in termini teorici, ma anche nella pratica per lo sviluppo 
di basso livello quali driver, kernel e addirittura sistemi operativi completi.

I progetti analizzati sono in costante sviluppo ed evoluzione;
le informazioni riportate in questa trattazione sono aggiornate ad Agosto 2025, ma potrebbero subire
variazioni nel tempo.

Tra le applicazioni più rilevanti sono presenti: l'integrazione di Rust nel kernel di Windows 11,
il progetto \textit{Rust for Linux} (\textit{RfL}) con i relativi sottoprogetti, l'implementazione 
di \textit{sudo-rs} promossa da Ubuntu e il sistema operativo \textit{Redox OS}.\ 

\section{Kernel di Windows 11}
L'adozione di Rust da parte di Microsoft risale al 2023, quando l'azienda ha iniziato a riprogettare sezioni critiche del
kernel del sistema operativo Windows 11, come riportato dal seguente articolo\cite{microsoft-rust}.

Prima di analizzare quest'adozione, è utile un breve excursus storico sull'evoluzione del kernel Windows, principalmente per comprendere l'importanza di questo cambiamento.
\begin{framed}
\noindent Lo sviluppo dei sistemi Microsoft iniziò con un kernel interamente scritto in assembly (\texttt{ASM8086}) nelle prime 
versioni di \textit{MS-DOS}.\ Con \textit{MS-DOS 3.0} venne introdotto il linguaggio C, ma il primo vero kernel scritto interamente in C
si ebbe con Windows NT 3.1 (\textbf{KERNEL.EXE}, 1993). Successivamente, C è rimasto il linguaggio principale per il kernel di Windows, con integrazioni C++ nelle
versioni successive.
\end{framed}
\noindent Il passaggio a Rust in Windows 11 è stato motivato da una combinazione di esigenze aziendali e del crescente interesse per il linguaggio Rust, che
iniziò a essere popolare proprio in questo periodo, grazie al modello offerto: garantire la sicurezza della memoria senza sacrificare le prestazioni.

In particolare, Rust ha permesso a Microsoft di affrontare due aspetti fondamentali:
\begin{itemize}
    \item \textbf{Sicurezza della memoria}: Windows ha una storia documentata alle spalle di errori legati alla memoria, quali \textit{null reference}, \textit{buffer overflow}, scritture illegali e altri. Il \textit{modello di ownership} offerto da Rust consente di prevenire queste problematiche già a tempo di compilazione;
    \item \textbf{Gestione della concorrenza}: Data la complessità Windows, anche gli errori di concorrenza sono frequenti. Il \textit{Borrow Checker} di Rust, insieme all'uso di \textit{smart pointers} per la condivisione dei dati, garantisce integrità e un uso corretto delle risorse condivise, eliminando errori quali \textit{data race}.
\end{itemize}
Va sottolineato che, ad oggi, si tratta di un'adozione parziale: il kernel di Windows 11 è tuttora scritto prevalentemente in C, con alcune porzioni in C++.
L'obiettivo dichiarato di Microsoft è intervenire sulle sezioni chiave del kernel e sulle nuove funzionalità, valutando caso per caso l'impiego di Rust.

Nonostante si tratti di un'adozione parziale, questa scelta rappresenta un traguardo significativo per Rust: guadagnare la fiducia
di un colosso tecnologico come Microsoft ha contribuito alla crescita della popolarità del linguaggio, specialmente nel panorama della programmazione di sistema.

\section{Rust for Linux}
Il progetto \textit{Rust for Linux} nasce con l'obiettivo di integrare il supporto a Rust 
come linguaggio di programmazione utilizzabile all'interno del kernel Linux, dimostrandone l'idoneità nello 
sviluppo di componenti di basso livello, principalmente driver, tradizionalmente 
implementati in C.

L'interesse verso Rust deriva principalmente dalle garanzie offerte dal linguaggio sotto gli aspetti di \textit{memory-safety} e \textit{thread-safety} senza
costi di esecuzione aggiuntivi. Grazie al \textit{modello di ownership} intere classi di errori vengono completamente prevenute a livello di compilazione,
come accessi a memoria non inizializzata, memoria non liberata, \textit{double free} a altri ancora, comuni nei sistemi sviluppati in C\footnote{Il \textit{modello di ownership} viene 
esposto nel capitolo tre~\ref{cap:03}, mentre nel capitolo quattro~\ref{sub:mem-safe} è possibile osservare quali errori vengono effettivamente 
eliminati grazie ad esso.}. \hfill 
\vspace{7pt} \\
\noindent Il progetto raccoglie un insieme di contributi al kernel, in gran parte rappresentato da driver per dispositivi fisici
(schede di rete, NVMe) e virtuali (GPU virtuali), sviluppati interamente in Rust.

La documentazione ufficiale è consultabile dal sito di Rust for Linux~\cite{rust-for-linux}. Inoltre, è opportuno osservare che il 
progetto è in continua evoluzione, le informazioni riportate in questa trattazione sono aggiornate ad Agosto 2025, ma potrebbero variare nel futuro. \hfill
\vspace{5pt} \\
\noindent Per comprendere l'importanza di questo progetto, è utile un breve excursus sull'evoluzione dei linguaggi supportati dal kernel linux.
\begin{framed}
\noindent Il kernel Linux venne rilasciato inizialmente nel 1991 da Linus Torvalds ed era quasi interamente scritto in C,
con alcune sezioni in assembly. Questa situazione rimase 
invariata fino al 2007, quando venne l'integrazione di
C++ nel kernel. 

Tuttavia, l'idea venne rifiutata da Torvalds stesso,
contrario all'utilizzo di un linguaggio considerato meno trasparente e più complesso rispetto a C,
 come riportato dal seguente articolo di \textit{Zeus News}~\cite{linus-cpp}, dove vengono esposte alcune motivazioni specifiche a riguardo.

 Solo nel 2022, con la versione 6.1, venne aggiunto un primo supporto sperimentale a Rust, sufficiente per permettere agli sviluppatori
di iniziare a scrivere codice Rust nel kernel e testarne l'integrazione.
\end{framed}
\noindent Al giorno d'oggi il kernel Linux consente lo sviluppo di moduli e driver, sia
in C che in Rust, definiti \textit{out-of-tree}: moduli sviluppati e mantenuti separatamente dal codice sorgente del kernel,
spesso proprietari o specifici per hardware particolare. \hfill
\vspace{7pt} \\
\noindent Il progetto \textit{Rust for Linux} si concentra soprattutto sullo sviluppo di moduli \textit{in-tree}, inclusi direttamente nella \textit{mainline} del kernel (i.e.\  incluse nel sorgente del kernel).
Tuttavia, il progetto raccoglie anche moduli \textit{out-of-tree}, permettendo agli sviluppatori un ambiente sicuro per sperimentare e validare 
soluzioni prima di proporle per un'inclusione ufficiale nella \textit{mainline}.\hfill 
\vspace{15pt}\\
\noindent Un concetto chiave introdotto dal progetto è quello di \textit{reference driver} (driver di riferimento), ovvero implementazioni in Rust che possono essere integrate 
nei sottosistemi senza sostituire i driver C esistenti.

\noindent Questi driver hanno diverse funzioni:
\begin{itemize}
    \item Definire astrazioni sicure per i nuovi driver, evitando la riscrittura o duplicato codice esistente;
    \item Fornire un modello di riferimento per gli sviluppatori C, mostrando come un driver equivalente possa essere realizzato in Rust;
    \item Sfruttare le infrastrutture già presenti \textit{in-tree} per preparare i sottosistemi a un'integrazione graduale e progressiva di Rust;
    \item Facilitare l'apprendimento graduale del linguaggio da parte degli sviluppatori del kernel;
    \item Valutare la convenienza dell'adozione: verificare quanta parte del codice possa essere scritta in modalità \texttt{safe}, quanti bug del driver originale C verrebbero effettivamente eliminati e quale sia l'impatto sulla manutenzione.
\end{itemize}
In molti casi, un \textit{reference driver} può essere semplicemente un prototipo o un banco di prova, più che un driver destinato all'uso in produzione.

\subsection{Moduli in mainline} 
Come precedentemente accennato, i moduli e driver \textit{in mainline} fanno ufficialmente parte del kernel: sono inclusi nel 
sorgente e compilati insieme ad esso, risultando disponibili senza necessità di installazioni aggiuntive.
La categoria \textit{in mainline} di \textit{Rust for Linux} comprende principalmente driver per schede di rete (\textit{Network Interface Cards}, \textbf{AMCC QT2025} e \textbf{ASIX}) e per GPU (\textbf{Nova} e \textbf{Tyr}), oltre ad 
alcuni moduli di utilità.

\paragraph{Driver per NIC}
Due dei principali moduli \textit{in-tree} del progetto sono driver per dispositivi di rete, \textbf{AMCC QT2025 PHY} e \textbf{ASIX PHY}.\ 

Il primo è un driver per l'omonimo dispositivo (transreceiver \textbf{AMCC QT2025}) e fornisce un'interfaccia verso lo 
stack di rete del kernel, facilitando l'interazione tra 
il dispositivo e il sistema operativo e la gestione delle funzionalità di rete.
È stato integrato nel kernel nella versione \texttt{6.12}.

Il secondo è destinato ai dispositivi Ethernet del produttore \textbf{ASIX}, ma ha finalità principalmente dimostrative:
è sviluppato come \textit{reference driver}, per fornire un esempio di implementazione di un driver \texttt{PHY} (layer fisico dello stack \texttt{ISO/OSI}) in Rust.
È stato introdotto nella versione \texttt{6.8}.

\paragraph{Driver per GPU}
Tra i moduli \textit{in-tree} rientrano anche due driver per schede grafiche: \textbf{Nova GPU} e \textbf{Tyr GPU}.\ 

\textbf{Nova GPU} è un driver per le schede grafiche NVIDIA a partire dalla seria RTX~2000, concepito come successore dell'attuale \textit{Nouveau}.
La descrizione dettagliata del driver è riportata nella sezione `\textit{Red Hat: Nova}'~\ref{sec:redhat-nova}.

\textbf{Tyr GPU} è un driver \textit{Direct Rendering Manager} (\textbf{DRM}) per le GPU \textit{Arm Mali} basate su \textit{CSF} (Command Stream Frontend), 
sviluppato come porting in Rust dell'attuale driver \textit{Panthor} (in C).\ 
Il progetto ha un team di sviluppo che comprende ingegneri provenienti da \textit{Collabora}, \textit{Arm} e \textit{Google}, e mira a fornire la 
stessa API per spazio utente attualmente offerta da \textit{Panthor}, così da poter sostituire direttamente il driver nel contesto di \textit{PanVK} (driver Vulkan).

\noindent Lo sviluppo di \textit{Tyr} procede su due rami distinti:
\begin{itemize}
    \item \textbf{Upstream}: Attualmente in grado di rilevare GPU su \textit{SoC} (\textit{System-on-Chip}) \texttt{RK3588}, leggere alcune sezioni della ROM della GPU e trasferirle allo spazio utente tramite chiamate API;\ 
    \item \textbf{Downstream}: Utilizzato come \textit{reference driver} per testare le nuove astrazioni proposte, prima della loro integrazione nella \textit{upstream}. Attualmente è in grado di inviare piccoli pacchetti di lavoro alla GPU.\ 
\end{itemize}
Il progetto \textit{Tyr} è iniziato a giugno 2025 e si trova ancora in fare iniziale, instabile e fortemente sperimentale.
Secondo la documentazione ufficiale (Sezione \textit{Users -- in mainline/Tyr GPU Driver})~\cite{rust-for-linux}, non gestisce ancora il controllo della corrente e implementa funzionalità limitate di recupero dagli errori, 
ma il team di sviluppo prevede di estenderle nei prossimi mesi.

\paragraph{Driver per Null block}
Il \textit{Null Block device} (\texttt{/dev/null}) è un dispositivo a blocchi virtuale utilizzato principalmente per test e benchmarking: scarta tutti i dati scritti e restituisce \texttt{EOF} se si legge da esso, senza usufruire di memoria o spazio di archiviazione fisico.

Il driver attuale, \texttt{null\_blk}, è scritto interamente in C e ha una nota storia di vulnerabilità legate alla gestione della memoria: un'analisi dei 
commit relativi al driver mostra che circa il \texttt{41\%} dei fix sono dovuti a errori di sicurezza della memoria\cite{null-blk}.
Ciò lo ha reso un ottimo candidato per un'implementazione in Rust.

A questo scopo, è stato sviluppato \texttt{rnull}, un driver scritto interamente in \texttt{safe} Rust, con porzioni minime di codice \texttt{unsafe}, incapsulate in astrazioni sicure
 per interagire con le \texttt{API C} del kernel.

 Attualmente \texttt{rnull} replica gran parte delle funzionalità di \texttt{null\_blk}, ma non è ancora completo e manca di alcune feature presenti nell'implementazione originale.

\paragraph{Generatore di codici QR per DRM Panic}
Questo modulo è destinato ai sottosistemi \textit{Direct Rendering Manager} (\textbf{DRM}) e ha lo scopo di semplificare l'analisi degli 
\textit{stack trace} generati in seguito a un \textit{kernel panic}.

Il problema di base è che i messaggi di errore del \textit{DRM} possono essere molto lunghi e poco pratici da copiare manualmente.
Il modulo genera un codice QR, scansionabile con uno smartphone, contenente le informazioni sull'errore, così da ottenere 
rapidamente i dettagli necessari all'analisi.

L'implementazione non richiede memoria o spazio di archiviazione aggiuntivi: sfrutta lo spazio 
libero nel buffer già riservato al processo per memorizzare il codice QR.\ 
È stato integrato nel kernel nella versione \texttt{6.12}.

\subsection{Moduli outside mainline}
Oltre a moduli inclusi nella \textit{mainline}, il progetto raccoglie anche sviluppi \textit{outside mainline}, ovvero non integrati direttamente nel kernel: 
pur essendo compatibili con una determinata versione del kernel, vengono mantenuti e distribuiti separatamente, richiedendo quindi installazioni
 aggiuntive prima di essere utilizzabili.

In questa categoria rientrano driver per dispositivi di storage (\textbf{NVMe}), GPU proprietarie (\textbf{Apple AGX}), filesystem (\textbf{PuzzleFS}) e moduli per Android.\hfill
\vspace{7pt}\\
\noindent Il progetto \textit{Rust for Linux} privilegia lo sviluppo di moduli \textit{in-tree}, ma ciò non rende meno rilevanti quelli \textit{out-of-tree}:
spesso si tratta di soluzioni pensate per contesti o hardware specifici; per questo, solitamente, la documentazione disponibile può risultare limitata.

\paragraph{Android ashmem}
\texttt{Ashmem} (\textit{Anonymous Shared Memory Subsystem for Android}) è un allocatore di memoria condivisa per Android, contettualmente simile a 
\texttt{POSIX SHM} ma con un'API più semplice e basata su file.

È progettato per liberare automaticamente le regioni di memoria condivisa quando il sistema è sotto pressione (ovvero quando la memoria fisica si sta saturando), caratteristica che lo rende particolarmente 
adatto a dispositivi con risorse limitate.

\paragraph{Driver per Android Binder}
Questo progetto mira a riscrivere in Rust il driver kernel per il \textbf{Binder} di Android.
Il \textit{Binder} è un componente fondamentale per la sicurezza e le prestazioni dei sistemi Android: gestisce la \textit{IPC} (\textit{Inter-Process Communication}) all'interno 
del \textit{sandbox}\footnote{Android isola l'esecuzione delle applicazioni in ambienti detti Sandbox, per cui ogni applicazione ha il proprio ambiente privato per la sua esecuzione, separato dalle altre.} di Android, permettendo la comunicazione tra applicazioni isolate.

La sua natura critica lo rende particolarmente vulnerabile a errori legati alla gestione della memoria, per cui trarrebbe significativi vantaggi 
dalle garanzie offerte dal \textit{modello di ownership} di Rust, sia intermini di sicurezza che di prestazioni.

\paragraph{Driver per Apple AGX}
Questo driver è destinato alla GPU \textbf{AGX} di Apple ed è accompagnato da binding \textit{DRM} (\textit{Direct Rendering Manager}) per lo spazio utente.
Oltre a far parte di \textit{Rust for Linux}, il driver rientra anche nel progetto \textit{Asahi Linux}, il quale mira a portare supporto Linux sulle 
CPU Apple Silicon.

L'interesse principale verso \textit{AGX} deriva proprio dal contesto di \textit{Asahi}: la documentazione tecnica più dettagliata è presente
nelle pagine ufficiali di tale progetto~\cite{asahi}.

Attualmente lo sviluppo è sviluppo è focalizzato sull'implementazione di driver per \textit{OpenGL} e \textit{Vulkan} e sul \textit{reverse engineering} del set di istruzioni 
supportato dalla GPU.\ 

\paragraph{Driver per NVMe}
Questo driver rappresenta il tentativo di sviluppare un driver \textbf{NVMe PCI} interamente in \texttt{safe} Rust, concepito principalmente come \textit{reference driver}.
L'obiettivo è dimostrare la fattibilità di astrazioni sicure per dispositivi ad alte prestazioni, oltre che a fornire un esempio concreto per sviluppi futuri.

Allo stato attuale si trova in fase sperimentale e instabile, non adatta a un uso in produzione.

\paragraph{Driver per filesystem PuzzleFS}
\textbf{PuzzleFS} è un filesystem per container progettato per superare alcune limitazioni dell'attuale stack \textit{OCI} (\textit{Open Container Initiative}).
Il progetto mira a ridurre la duplicazione dei dati, garantire build riproducibili, supportare il \textit{mounting} diretto e garantire la sicurezza della memoria.

Il driver, scritto in Rust, implementa queste caratteristiche attraverso:
\begin{itemize}
    \item \textbf{Riduzione della duplicazione}: utilizzo dell'algoritmo \textit{FastCDC} per condividere segmenti di memoria tra i vari layer;
    \item \textbf{Build riproducibili}: definizione di una rappresentazione canonica del formato delle immagini;
    \item \textbf{Sicurezza della memoria}: ottenuta implicitamente grazie al \textit{modello di ownership} di Rust.
\end{itemize}

\subsection{Impatto del progetto}
Tra i recenti esempi di integrazione di Rust in progetti esistenti, \textit{Rust for Linux} è senza dubbio quello che ha avuto il maggiore impatto tecnico 
e mediatico, generando anche un ampio dibattito all'interno della community \textit{open source}.

Il motivo è semplice ma fondamentale: il progetto coinvolge il kernel Linux, cuore di vari sistemi operativi alla base di gran parte 
dell'infrastruttura digitale odierna, sviluppato e mantenuto da una comunità vasta e con una cultura tecnica consolidata.

A confronto con:
\begin{itemize}
    \item \textbf{Kernel di Windows 11}: Windows è un sistema proprietario sviluppato internamente da Microsoft, quindi l'integrazione di Rust non genera lo stesso dibattito pubblico né ha lo stesso impatto sulla community open source;
    \item \textbf{sudo-rs}: riscrittura in Rust del comando \texttt{sudo}, importante per la sicurezza, ma limitato a un singolo strumento, non all'intero sistema;
    \item \textbf{Redox OS}:\  sistema operativo scritto interamente in Rust, ma con adozione limitata (è considerato principalmente un progetto `\textit{di nicchia}') rispetto a Linux, il quale è alla base di Android e della maggior parte dei server.
\end{itemize}

\paragraph{Motivazioni dell'importanza}
L'integrazione di Rust nel kernel Linux rappresenta il primo tentativo concreto di introdurre un linguaggio con garanzie di sicurezza della memoria nella \textit{mainline} del kernel.
L'obiettivo è ridurre la classe di vulnerabilità legate a errori di gestione della memoria, mantenendo le prestazioni richieste da un sistema operativo.

L'importanza è amplificata dal fatto che Linux è alla base di una porzione enorme dell'ecosistema tecnologico globale: dai dispositivi mobili Android ai 
vari server che alimentano servizi cloud e web. Qualsiasi cambiamento strutturale al kernel ha quindi effetti su larga scala.

Infine, si tratta di un cambiamento che rompe una tradizione radicata: dal 1991 il kernel Linux è scritto quasi interamente in C, e in passato 
altri linguaggi (incluso C++) non sono stati accettati. L'introduzione di Rust non è solo un aggiornamento tecnico, ma anche una 
modifica della filosofia di sviluppo del progetto.

\paragraph{Conseguenze socio-culturali}
L'ultima proposta per introdurre un nuovo linguaggio nel kernel risale nel 2007, quando Torvalds rifiutò l'adozione di C++. 
Questa storia rende l'accettazione, seppure parziale, di Rust un segnale di apertura.

In una prima occasione, Linus Torvalds ha espresso un approccio pragmatico verso Rust, riconoscendo sia le resistenze culturali che i possibili benefici tecnici:

\begin{quote}
`Rust is a very different thing, and there are a lot of people who are used to the C model. They don’t like the differences, but that’s OK [\ldots] 
Clearly, some people just don’t like the notion of Rust and having Rust encroach on their area. But we’ve only been doing Rust for a couple of 
years, so it’s way to early to say Rust is a failure'. \hfill \\
\emph{-- Linus Torvalds, discussione alla `Linux Kernel Mailing List', 2022}
\end{quote}

\noindent In un'altra occasione, ha chiarito di non considerare Rust un rimpiazzo totale di C, ma uno strumento aggiuntivo, utile in casi specifici:
\begin{quote}
`I do not think Rust will take over the kernel, and I don’t think anybody is even suggesting that. But 
I do think Rust can be a good tool for some things, and we should use the best tool for the job'. \hfill \\
\emph{-- Linus Torvalds, conferenza `Linux in the Multiverse', 2024}
\end{quote}

\noindent Queste dichiarazioni evidenziano due aspetti fondamentali: da un lato, l'esistenza di una divisione culturale tra sviluppatori più legati al modello C e
sostenitori di Rust; dall'altro, la volontà di valutare Rust su basi pratiche e a lungo termine, senza pregiudizi definitivi e senza trasformarlo in una questione ideologica.

\section{Red Hat: Nova}\label{sec:redhat-nova}
\textbf{Nova} è un progetto sviluppato dall'azienda Red Hat, parte integrante dell'iniziativa \textit{Rust for Linux}. Si tratta di un driver per \textit{GSP}, un componente 
presente nelle schede grafiche NVIDIA di nuova generazione, dalla serie RTX~2000 in poi.

Il \textit{GSP} è un componente hardware e firmware integrato nella GPU che consente di gestire quest'ultima come se fosse un sistema embedded.
Tra le sue funzioni principali si trovano: la gestione dell'alimentazione, la gestione del clock, l'inizializzazione dell'hawdware, lo scheduling delle code e
il controllo termico. Permette di comunicare con la GPU come se fosse un'entità autonoma interna al sistema, sollevando la CPU da tutte le funzionalità 
precedentemente elencate. \hfill
\vspace{10pt} \\
\noindent Prima dell'introduzione del \textit{GSP}, il driver open source \textit{Nouveau}, sviluppato principalmente tramite \textit{reverse engineering}\footnote{
NVIDIA è nota per non rilasciare pubblicamente la documentazione delle proprie GPU, principalmente per motivi di marketing, per poter 
offrire il proprio driver proprietario, maggiormente ottimizzato rispetto alle alternative open source.
}, soffriva di limitazioni 
in termini di prestazioni e stabilità rispetto ai driver proprietari forniti da NVIDIA.\ 

Con il \textit{GSP}, molte delle funzionalità ricostruite tramite \textit{reverse engineering} sono ora gestite direttamente da 
questo processore dedicato, il quale funge da strato di astrazione che permette la comunicazione tra GPU e kernel tramite \textit{IPC}.\ 
Questo cambiamento strutturale ha reso necessario lo sviluppo di un nuovo driver specifico.\hfill
\vspace{10pt} \\
\noindent I motivi che hanno portato Red Hat a scegliere Rust per lo sviluppo di \textit{Nova} sono fondamentalmente tre:
\begin{itemize}
    \item \textbf{memory-safety}: il motivo principale risiede nella garanzia di sicurezza della memoria offerta da Rust, così da prevenire in partenza la maggior parte di bug;
    \item \textbf{thread-safety}: le GPU sono composte da un numero elevato di \textit{thread}, per cui il driver trae vantaggio dalla gestione sicura della concorrenza di Rust;
    \item \textbf{sperimentazione}: trattandosi di un nuovo driver e non di una riscrittura, vi era l'occasione per sperimentare e testare il linguaggio.
\end{itemize}


Nova è strutturano in due componenti principali:
\begin{itemize}
    \item \textbf{nova-core}: esegue le operazioni a basso livello, come l'avvio del \textit{GSP} e l'interazione, tramite quest'ultimo, con l'hawdware;
    \item \textbf{nova-DRM}:\  fornisce un'interfaccia astratta conforme al \textit{DRM} (\textit{Direct Rendering Manager}), fondamentale per la comunicazione con lo spazio utente.
\end{itemize}
Questa architettura modulare permette di combinare \textit{nova-core} con differenti driver grafici, oltre a \textit{nova-DRM}.\ 
Ad esempio, è possibile impiegare \textit{VFIO} per assegnare la GPU a macchine virtuali, sfruttando la possibilità, supportata a livello firmware, di creare più \textit{vGPU} (GPU virtuali). 

Attualmente, \textit{nova-DRM} è sviluppato principalmente come driver grafico per ambienti virtualizzati, ma può essere utilizzato anche su sistemi fisici, sebbene non sia ottimizzato per questo ambito.

\section{Ubuntu: sudo-rs}
Sebbene non faccia parte del kernel, il comando \texttt{sudo} è uno degli strumenti più importanti e diffusi nel mondo Linux.
La sua funzione è fondamentale: \textit{Substitute User DO} consente l'esecuzione di comandi con i privilegi di un'altro utente, solitamente più elevati,
come quelli di un utente ristretto o di super-utente.
Proprio per questo, è uno degli strumenti più delicati dal punto di vista della sicurezza di un sistema. \hfill
\vspace{5pt}\\
\noindent Dalla sua prima introduzione fino a oggi, \texttt{sudo} è stato sviluppato nel linguaggio C. Come riportato in~\cite{ubuntu-sudo-rs}, tuttavia, Canonical ha annunciato che,
a partire dalla versione \texttt{25.10} di Ubuntu, verrà introdotta una nuova implementazione del comando, scritta interamente in Rust, \texttt{sudo-rs}.

La scelta di Rust deriva dalla necessità di garantire una maggiore sicurezza della memoria e ridurre le vulnerabilità
tipiche delle implementazioni in C, come accessi a memoria non valida. Il \textit{modello di ownership} di Rust 
rappresenta una scelta perfetta per questo scopo, eliminando intere classi di errori pur mantenendo prestazioni comparabili a quelle di C. \hfill
\vspace{10pt}\\
\noindent Il progetto, guidato dalla \textit{Trifecta Tech Foundation}, punta a migliorare la sicurezza di uno degli strumenti più sensibili dei sistemi Linux.
Alla sua realizzazione contribuisce anche Todd Miller, storico mantenitore del comando negli ultimi trent'anni, fornendo supporto tecnico e linee guida 
al team di sviluppo del progetto.

Le principali vulnerabilità della versione attuale riguardano semplici errori di gestione della memoria, in particolare 
\textit{use-after-free} e accessi oltre i limiti.
Queste problematiche possono essere sfruttate per eseguire attacchi di tipo \textit{privilege escalation}\footnote{La \textit{privilege escalation} rappresenta uno scenario in cui 
un utente con permessi limitati (e.g.\ \textit{guest}) ottiene, sfruttando le vulnerabilità di un sistema, privilegi più elevati (e.g.\ \textit{root}).}. \hfill
\vspace{10pt} \\
\noindent Gli obiettivi del progetto \texttt{sudo-rs} includono:
\begin{itemize}
    \item Migliorare la gestione dell'escaping dei caratteri speciali nella shell, evitando l'esecuzione di comandi indesiderati e potenzialmente malevoli;
    \item Integrare il controllo sui profili di \texttt{AppArmor};
    \item Supportare l'utilizzo di \texttt{sudoedit};
    \item Garantire retrocompabitilità con kernel precedenti alla versione 5.9, come Ubuntu \texttt{20.04 LTS}.\ 
\end{itemize}
La filosofia del gruppo di sviluppo segue il principio \textit{`less is more'}: evitare un eccesso di funzionalità iniziali per ridurre la complessità e il rischio di
introdurre errori logici da risolvere in seguito.

Per questo motivo, \texttt{sudo-rs} non mira a essere un rimpiazzo totale di \texttt{sudo}: molte feature, specialmente quelle meno utilizzate o considerate meno importanti potrebbero venire non implementate inizialmente. \hfill
\vspace{7pt} \\
\noindent Il nuovo comando è già disponibile per gli utenti che desiderano testarlo\footnote{È possibile installare il comando tramite il package manager \texttt{apt}, cercando \texttt{rust-sudo-rs}; successivamente, sarà disponibile come `\texttt{sudo-rs}'.} e fornire feedback alla comunità.

Come nota finale, Canonical garantisce che la versione originale in C del comando continuerà a essere mantenuta e distribuita,
così da lasciare all'utente la libertà di scegliere quale versione adottare, in base alle proprie preferenze o esigenze.

\section{Redox OS}
\texttt{Redox OS} rappresenta una pietra miliare per il linguaggio Rust, in particolar modo nell'ambito della programmazione di sistema.
Redox, come riportato dal sito ufficiale~\cite{redox-os}, è un sistema operativo general purpose Unix-like basato su microkernel; molti sistemi operativi rientrano in questa categoria (come Minix o BlackBerry QNX),
ma ciò che distingue Redox risiede nell'implementazione, interamente in Rust. 

La scelta di usare solamente Rust ha l'obiettivo di mettere alla luce le capacità pratiche del linguaggio 
nello sviluppo sia di (micro)kernel che di programmi general purpose, fornendo un'alternativa completa a Linux o BSD.\hfill
\vspace{7pt} \\
\noindent Il progetto Redox ha riscontrato successo grazie a una combinazione di design basato su microkernel,
impiego di Rust, compatibilità con POSIX e con la maggior parte dei programmi Linux/BSD grazie alla propria libreria C (anch'essa sviluppata in Rust).

\paragraph{Design basato su microkernel}
Un microkernel è un insieme di software minimale che offre i meccanismi necessari per implementare un sistema operativo: il microkernel da solo
non è sufficiente, è necessario integrare moduli aggiuntivi per ricoprire le funzionalità di un sistema operativo.\ 

Questo permette il caricamento, la modifica e la rimozione di moduli a runtime, senza la necessità di riavviare il sistema come conseguenza di ogni cambiamento.
Inoltre, in quanto i moduli sono esterni al microkernel, essi vivono nello spazio utente, garantendo isolamento dei bug: anche se un intero modulo
andasse in crash, non avrebbe conseguenze sul resto del sistema\footnote{Questo rappresenta uno dei maggiori vantaggi dell'approccio microkernel. Non vi è il rischio che l'intero sistema si corrompa in seguito al crash di una singola applicazione o modulo.} (il kernel non risentirebbe del crash).

\paragraph{Scrittura in Rust}
Redox trae beneficio dai vari aspetti caratteristici del linguaggio, nonché da molte delle garanzie offerte:
\begin{itemize}
    \item Il \textit{modello di ownership} impone regole che prevengono la maggior parte di errori legati alla memoria, come \textit{null reference}, \textit{use-after-free}, \textit{unfreed memory} e \textit{double free}, nonché \textit{data race};
    \item Il \textit{Borrow Checker} vieta la condivisione non sicura di risorse, imponendo vincoli rigidi per garantire l'integrità dei dati condivisi da più thread o processi;
    \item L'utilizzo di astrazioni sicure come \texttt{Option<T>} e \texttt{Result<T,E>} obbliga il programmatore a gestire esplicitamente sia il successo sia l'eventuale fallimento di un'operazione, evitando accessi a dati non validi;
    \item Tutti questi meccanismi, uniti alla sintassi restrittiva del linguaggio, eliminano classi intere di bug, lasciando solo quelli legati alla logica applicativa.
\end{itemize}
Sia il microkernel che i vari driver sono implementati interamente in Rust, sfruttando le caratteristiche sopra citate e senza 
richiedere un ulteriore sforzo per garantire la \textit{thread-safety} o la \textit{memory-safety}\footnote{È richiesto uno sforzo maggiore solo durante la fase iniziale dello sviluppo, ma una volta raggiunta la compilazione, si ha la garanzia che la memoria e la concorrenza sono gestite senza incoerenze.}.

\paragraph{Compatibilità con POSIX}
Redox mira a essere compatibile con la maggior parte delle applicazioni Linux e, più in generale, a rispettare lo standard \texttt{POSIX}.\ 
Tale compatibilità non è di tipo binario, ma è ottenuta a livello di codice sorgente: in molti casi è sufficiente ricompilare l'applicazione per 
renderla eseguibile su Redox.

Questo risultato è reso possibile da \texttt{relibc}, la libreria C di Redox, scritta interamente in Rust per mantenere coerenza con la filosofia del progetto.
Grazie a \texttt{relibc}, Redox supporta già numerose applicazioni fondamentali, tra cui \texttt{GNU bash}, \texttt{Git}, \texttt{Ffmpeg}, \texttt{GCC} e \texttt{LLVM}, rendendolo
potenzialmente utilizzabile anche da un utente finale.

\paragraph{Considerazioni su Redox}
È necessario osservare che Redox, nonostante sia nato come sistema operativo general purpose, è ancora in fase di sviluppo, non ancora 
maturo per un utilizzo quotidiano, specialmente se paragonato a colossi del calibro di Windows, MacOS o Ubuntu, i quali forniscono una buona esperienza utente già `\textit{out of the box}'.

Ciononostante, Redox costituisce una dimostrazione concreta della maturità e dell'usabilità di Rust per lo sviluppo di sistemi operativi completi, confermandone
l'applicabilità ben oltre la teoria.

\section{Considerazioni sui progetti analizzati}
In questo capitolo, sono stati esaminati diversi progetti concreti 
che mostrano come Rust possa essere integrato nei sistemi operativi, sia 
tramite l'aggiunta di moduli specifici che tramite la riscrittura completa di 
componenti esistenti.

Un aspetto comune di tutti gli esempi presentati è la volontà di affrontare uno dei 
principali punti deboli dell'uso del C:\ la gestione della memoria.
Il \textit{modello di ownership} di Rust, come discusso nel capitolo tre: `\textit{Gestione della memoria in Rust}'~\ref{cap:03} 
e mostrato nel capitolo quattro: `\textit{Sistemi Operativi}'~\ref{cap:04}, riesce a 
eliminare già a tempo di compilazione molti degli errori legati alla gestione 
della memoria, i quali in C emergerebbero solo a tempo di esecuzione. \hfill
\vspace{10pt}\\
\noindent Le strategie adottate, tuttavia, sono diverse: alcuni progetti optano 
per un'interazione graduale (come il kernel di Windows 11 e \textit{Rust for Linux}), 
mentre altri per una sostituzione totale (come \texttt{sudo-rs}). 
Allo stesso modo, in alcuni casi l'attenzione è posta interamente sulla 
sicurezza del sistema (Windows 11 e \textit{Rust for Linux}), mentre in altri viene 
data importanza all'esperienza dell'utente finale (\textit{Redox OS}).

Nel complesso, queste iniziative mostrano come Rust non sia più solamente un 
linguaggio \textit{promettente} e sperimentale, ma uno strumento concreto, impiegabile
in contesti reali e complessi, con risultati effettivi nella direzione 
di maggiore sicurezza e affidabilità dei sistemi.